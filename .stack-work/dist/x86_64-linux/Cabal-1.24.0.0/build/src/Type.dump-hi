
==================== FINAL INTERFACE ====================
2016-12-03 04:02:24.114872 UTC

interface neural-net-0.1.0.0-SYgV3Sx5uw5ZT4aENrU9C:Type 8001
  interface hash: b85a3ddcc8c430834794f501b81f448d
  ABI hash: f48ab537fd1248e12ff69cf644c6049f
  export-list hash: 1faf231b01dbc5294c5ce26a23f6b145
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Type.Input
  Type.Neuron{Type.Neuron}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
97d1d92718a71249f87e582753e38144
  $fShowNeuron :: GHC.Show.Show Type.Neuron
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Type.Neuron
                  Type.$fShowNeuron_$cshowsPrec
                  Type.$fShowNeuron_$cshow
                  Type.$fShowNeuron_$cshowList -}
97d1d92718a71249f87e582753e38144
  $fShowNeuron1 :: Type.Neuron -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: Type.Neuron) ->
                 case w of ww { Type.Neuron ww1 ww2 ->
                 Type.$w$cshowsPrec 0# ww1 ww2 }) -}
b041d79692c4bc02fdef7443627faa11
  $fShowNeuron2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Neuron "#) -}
2d41de776ad57d28f990273f005c519e
  $fShowNeuron3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
97d1d92718a71249f87e582753e38144
  $fShowNeuron_$cshow :: Type.Neuron -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Type.Neuron) ->
                 case w of ww { Type.Neuron ww1 ww2 -> Type.$w$cshow ww1 ww2 }) -}
97d1d92718a71249f87e582753e38144
  $fShowNeuron_$cshowList :: [Type.Neuron] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Type.Neuron
                   Type.$fShowNeuron1) -}
97d1d92718a71249f87e582753e38144
  $fShowNeuron_$cshowsPrec ::
    GHC.Types.Int -> Type.Neuron -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(U,1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Type.Neuron) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Type.Neuron ww3 ww4 ->
                 Type.$w$cshowsPrec ww1 ww3 ww4 } }) -}
2c6b850856b79aa3177158bf9e86b73f
  $tc'Neuron :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1226591838187026228##
                   13695448685135612557##
                   Type.$trModule
                   Type.$tc'Neuron1) -}
8dcb1e5be5c69b945f59380abf0460bc
  $tc'Neuron1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Neuron"#) -}
0e9a82e36b86904d46ea8670eedeb86c
  $tcNeuron :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8793569958201854651##
                   14263434264741380506##
                   Type.$trModule
                   Type.$tcNeuron1) -}
8ed072ad1e9f0ffb8aaf495674be173f
  $tcNeuron1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Neuron"#) -}
4491b638c0a02088d843e899d18fffa5
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Type.$trModule2 Type.$trModule1) -}
166c65ad8589cb2a6a5ce1b029ae1689
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Type"#) -}
b302fe7b2003488d89db0ce07955ce9d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "neural-net-0.1.0.0-SYgV3Sx5uw5ZT4aENrU9C"#) -}
66736f1a61056a11803d211b89b882c2
  $w$cshow ::
    [GHC.Types.Double] -> GHC.Types.Double -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Types.Double])
                   (ww1 :: GHC.Types.Double) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Type.$fShowNeuron2
                   (GHC.Show.showList__
                      @ GHC.Types.Double
                      GHC.Float.$fShowDouble1
                      ww
                      (GHC.Types.:
                         @ GHC.Types.Char
                         GHC.Show.showSpace1
                         (case ww1 of ww2 { GHC.Types.D# ww3 ->
                          GHC.Float.$w$sshowSignedFloat
                            GHC.Float.$fShowDouble_$sshowFloat
                            Type.$fShowNeuron3
                            ww3
                            (GHC.Types.[] @ GHC.Types.Char) })))) -}
9fc89e3f17b27e8decd3f2ebb41664b7
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> [GHC.Types.Double] -> GHC.Types.Double -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,U><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: [GHC.Types.Double])
                   (ww2 :: GHC.Types.Double) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = case ww2 of ww3 { GHC.Types.D# ww4 ->
                     GHC.Float.$w$sshowSignedFloat
                       GHC.Float.$fShowDouble_$sshowFloat
                       Type.$fShowNeuron3
                       ww4 }
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Type.$fShowNeuron2
                       (GHC.Show.showList__
                          @ GHC.Types.Double
                          GHC.Float.$fShowDouble1
                          ww1
                          (GHC.Types.: @ GHC.Types.Char GHC.Show.showSpace1 (g x)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 x)) }) -}
602440102f78d29de4ed0f56b5b88ec2
  type Input = [GHC.Types.Double]
97d1d92718a71249f87e582753e38144
  data Neuron = Neuron [GHC.Types.Double] GHC.Types.Double
instance [safe] GHC.Show.Show [Type.Neuron] = Type.$fShowNeuron
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

