
==================== FINAL INTERFACE ====================
2016-12-03 04:11:25.07844 UTC

interface neural-net-0.1.0.0-SYgV3Sx5uw5ZT4aENrU9C:Training 8001
  interface hash: 0483b2467ccfbfaf04adf5f7dd33e734
  ABI hash: 2cf10c3f95e76f91c7a3de06b9e0bd63
  export-list hash: 80ded65b1c7c0728efe49037cd544411
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Training.alpha
  Training.backPropagation
  Training.forwardSig
  Training.hLearn
  Training.oLearn
  Training.sigmoid
  Training.training
module dependencies: Type
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Float 469226b1bc53433e95d0167dec5d0312
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  Type f48ab537fd1248e12ff69cf644c6049f
  exports: 1faf231b01dbc5294c5ce26a23f6b145
  Input 602440102f78d29de4ed0f56b5b88ec2
  Neuron d88d3f9b9224584cd291cf631eb06f6a
  Neuron 97d1d92718a71249f87e582753e38144
a9d039f22e847ca113e29c64c3523779
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Training.$trModule2
                   Training.$trModule1) -}
a819a5b82f76fbb7e02230290ede23a1
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Training"#) -}
04c45efd8251a4fad230c8b2f216c50c
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "neural-net-0.1.0.0-SYgV3Sx5uw5ZT4aENrU9C"#) -}
f89d979686106583524663ffd78e2031
  $wbackPropagation ::
    GHC.Types.Double
    -> [Type.Input]
    -> [Type.Neuron]
    -> Type.Neuron
    -> (# GHC.Types.Double, [Type.Neuron], Type.Neuron #)
  {- Arity: 4, Strictness: <L,U(U)><S,1*U><L,U><L,U(U,U(U))>,
     Inline: [0] -}
eb6dd6d2d654929f5132479abfdb8784
  $wgo ::
    [GHC.Types.Double]
    -> [GHC.Types.Double] -> GHC.Prim.Double# -> GHC.Prim.Double#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,U>,
     Inline: [0] -}
5eb5fb499962370d271ab59c8849ad97
  $whLearn ::
    [Type.Neuron]
    -> [GHC.Types.Double]
    -> [GHC.Types.Double]
    -> Type.Input
    -> GHC.Types.Double
    -> [Type.Neuron]
  {- Arity: 5, Strictness: <S,U><L,1*U><L,1*U><L,U><L,U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: [Type.Neuron])
                   (w1 :: [GHC.Types.Double])
                   (ww :: [GHC.Types.Double])
                   (w2 :: Type.Input)
                   (w3 :: GHC.Types.Double) ->
                 let {
                   djList :: [GHC.Types.Double]
                   = GHC.List.zipWith
                       @ GHC.Types.Double
                       @ GHC.Types.Double
                       @ GHC.Types.Double
                       (\ (wn :: GHC.Types.Double) (hOut1 :: GHC.Types.Double)[OneShot] ->
                        case hOut1 of wild { GHC.Types.D# x ->
                        case wn of wild1 { GHC.Types.D# y ->
                        case Training.hLearn_go1
                               w2
                               (GHC.List.lastError
                                  @ GHC.Types.Double) of wild2 { GHC.Types.D# x1 ->
                        case w3 of wild3 { GHC.Types.D# y1 ->
                        GHC.Types.D#
                          (GHC.Prim.*##
                             (GHC.Prim.*##
                                (GHC.Prim.*##
                                   (GHC.Prim.*## (GHC.Prim.*## x (GHC.Prim.-## 1.0## x)) y)
                                   (GHC.Prim.-## x1 y1))
                                y1)
                             (GHC.Prim.-## 1.0## y1)) } } } })
                       ww
                       w1
                 } in
                 Training.hLearn_go
                   w
                   (GHC.List.zipWith
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      Training.hLearn3
                      w2
                      djList)
                   (GHC.List.zipWith
                      @ Type.Neuron
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      Training.hLearn2
                      w
                      (GHC.Base.map
                         @ GHC.Types.Double
                         @ GHC.Types.Double
                         Training.hLearn1
                         djList))) -}
4ebedca176d1429daa8a6a41c07bc2f0
  $woLearn ::
    [GHC.Types.Double]
    -> GHC.Types.Double
    -> [GHC.Types.Double]
    -> Type.Input
    -> GHC.Types.Double
    -> (# [GHC.Types.Double], GHC.Types.Double #)
  {- Arity: 5, Strictness: <L,1*U><L,1*U(U)><L,1*U><L,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: [GHC.Types.Double])
                   (ww1 :: GHC.Types.Double)
                   (w :: [GHC.Types.Double])
                   (w1 :: Type.Input)
                   (w2 :: GHC.Types.Double) ->
                 let {
                   d :: GHC.Types.Double
                   = case Training.oLearn_go
                            w1
                            (GHC.List.lastError @ GHC.Types.Double) of wild { GHC.Types.D# x ->
                     case w2 of wild1 { GHC.Types.D# y ->
                     GHC.Types.D#
                       (GHC.Prim.*##
                          (GHC.Prim.*## (GHC.Prim.-## x y) y)
                          (GHC.Prim.-## 1.0## y)) } }
                 } in
                 (# GHC.List.zipWith
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      @ GHC.Types.Double
                      GHC.Float.plusDouble
                      ww
                      (GHC.Base.map
                         @ GHC.Types.Double
                         @ GHC.Types.Double
                         (\ (x :: GHC.Types.Double) ->
                          case x of wild { GHC.Types.D# x1 ->
                          case d of wild1 { GHC.Types.D# y ->
                          GHC.Types.D# (GHC.Prim.*## (GHC.Prim.*## x1 y) 10.0##) } })
                         w),
                    case ww1 of wild { GHC.Types.D# x ->
                    case d of wild1 { GHC.Types.D# y ->
                    GHC.Types.D# (GHC.Prim.+## x (GHC.Prim.*## -10.0## y)) } } #)) -}
dee54a86d7f823c71e1bba50dacbfc14
  $wtraining ::
    GHC.Prim.Double#
    -> [Type.Input]
    -> [Type.Neuron]
    -> Type.Neuron
    -> (# GHC.Types.Double, [Type.Neuron], Type.Neuron #)
  {- Arity: 4, Strictness: <S,U><L,U><L,U><L,U(U,U(U))>,
     Inline: [0] -}
72af7fcb32e95fa2eda76652252f9c1d
  alpha :: GHC.Types.Double
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.D# 10.0##) -}
1927cfaacf70d123cd2ec0ddccba178a
  backPropagation ::
    GHC.Types.Double
    -> [Type.Input]
    -> [Type.Neuron]
    -> Type.Neuron
    -> (GHC.Types.Double, [Type.Neuron], Type.Neuron)
  {- Arity: 4, Strictness: <L,U(U)><S,1*U><L,U><L,U(U,U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Types.Double)
                   (w1 :: [Type.Input])
                   (w2 :: [Type.Neuron])
                   (w3 :: Type.Neuron) ->
                 case Training.$wbackPropagation
                        w
                        w1
                        w2
                        w3 of ww { (#,,#) ww1 ww2 ww3 ->
                 (ww1, ww2, ww3) }) -}
820359d87f63c4c456b021fce69f8103
  forwardSig :: Type.Input -> Type.Neuron -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U><S(LS(S)),1*U(1*U,1*U(U))>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Type.Input) (w1 :: Type.Neuron) ->
                 case w1 of ww { Type.Neuron ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.D# ww4 ->
                 case Training.$wgo w ww1 0.0## of ww5 { DEFAULT ->
                 case GHC.Prim./##
                        1.0##
                        (GHC.Prim.+##
                           1.0##
                           (GHC.Prim.expDouble#
                              (GHC.Prim.negateDouble#
                                 (GHC.Prim.-## ww5 ww4)))) of ww6 { DEFAULT ->
                 GHC.Types.D# ww6 } } } }) -}
43ff2583143b62b98246422cbbee233f
  hLearn ::
    [Type.Neuron]
    -> [GHC.Types.Double]
    -> Type.Neuron
    -> Type.Input
    -> GHC.Types.Double
    -> [Type.Neuron]
  {- Arity: 5, Strictness: <S,U><L,1*U><S,1*U(1*U,A)><L,U><L,U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: [Type.Neuron])
                   (w1 :: [GHC.Types.Double])
                   (w2 :: Type.Neuron)
                   (w3 :: Type.Input)
                   (w4 :: GHC.Types.Double) ->
                 case w2 of ww { Type.Neuron ww1 ww2 ->
                 Training.$whLearn w w1 ww1 w3 w4 }) -}
98e93b7c37ea5aa0b92fef6c66c7ffc5
  hLearn1 :: GHC.Types.Double -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (dj :: GHC.Types.Double) ->
                 case dj of wild1 { GHC.Types.D# y ->
                 GHC.Types.D# (GHC.Prim.*## -10.0## y) }) -}
eace8230f89ceb0678f1600a64f3f2ff
  hLearn2 :: Type.Neuron -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(A,1*U(U))><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Type.Neuron) (fixT :: GHC.Types.Double)[OneShot] ->
                 case ds of wild { Type.Neuron ds1 vh ->
                 GHC.Float.plusDouble vh fixT }) -}
f0aa38f4852800b7ed17446e49acb2b0
  hLearn3 :: GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (input :: GHC.Types.Double) (dj :: GHC.Types.Double)[OneShot] ->
                 case input of wild1 { GHC.Types.D# y ->
                 case dj of wild2 { GHC.Types.D# y1 ->
                 GHC.Types.D# (GHC.Prim.*## (GHC.Prim.*## 10.0## y) y1) } }) -}
ff51dcfe7899c1c503b0ce3b50f4e5a6
  hLearn_go ::
    [Type.Neuron]
    -> [GHC.Types.Double] -> [GHC.Types.Double] -> [Type.Neuron]
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,1*U> -}
68c2d7d05797df0bff0ed8345445c2ec
  hLearn_go1 ::
    [GHC.Types.Double] -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
e4831cc8ec03e4d7b55d07227c29caad
  oLearn ::
    Type.Neuron
    -> [GHC.Types.Double]
    -> Type.Input
    -> GHC.Types.Double
    -> Type.Neuron
  {- Arity: 4,
     Strictness: <S,1*U(1*U,1*U(U))><L,1*U><L,1*U><L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: Type.Neuron)
                   (w1 :: [GHC.Types.Double])
                   (w2 :: Type.Input)
                   (w3 :: GHC.Types.Double) ->
                 case w of ww { Type.Neuron ww1 ww2 ->
                 case Training.$woLearn ww1 ww2 w1 w2 w3 of ww3 { (#,#) ww4 ww5 ->
                 Type.Neuron ww4 ww5 } }) -}
871c47316cdcdc8cba44b318196e96db
  oLearn_go ::
    [GHC.Types.Double] -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)> -}
fcbcb54158e5df7cca5d881622abffba
  sigmoid :: GHC.Types.Double -> GHC.Types.Double
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (u :: GHC.Types.Double) ->
                 case u of wild { GHC.Types.D# x ->
                 case GHC.Prim./##
                        1.0##
                        (GHC.Prim.+##
                           1.0##
                           (GHC.Prim.expDouble#
                              (GHC.Prim.negateDouble# x))) of wild2 { DEFAULT ->
                 GHC.Types.D# wild2 } }) -}
77b6c76bcb48d9f078c74b53f2a2ac56
  training ::
    GHC.Types.Double
    -> [Type.Input]
    -> [Type.Neuron]
    -> Type.Neuron
    -> (GHC.Types.Double, [Type.Neuron], Type.Neuron)
  {- Arity: 4, Strictness: <S(S),1*U(U)><L,U><L,U><L,U(U,U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: GHC.Types.Double)
                   (w1 :: [Type.Input])
                   (w2 :: [Type.Neuron])
                   (w3 :: Type.Neuron) ->
                 case w of ww { GHC.Types.D# ww1 ->
                 case Training.$wtraining
                        ww1
                        w1
                        w2
                        w3 of ww2 { (#,,#) ww3 ww4 ww5 ->
                 (ww3, ww4, ww5) } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

